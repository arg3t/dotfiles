#!/usr/bin/env python

import argparse
import subprocess
import os
import fnmatch
import sys

# Try to import argcomplete
try:
    import argcomplete
except ImportError:
    argcomplete = None

# pathspec is required for the non-git fallback
try:
    import pathspec
except ImportError:
    print("Error: The 'pathspec' library is required for non-git directories.", file=sys.stderr)
    print("Please install it: pip install pathspec", file=sys.stderr)
    pathspec = None

def get_git_files(directory):
    """
    Uses 'git ls-files' to get all files not excluded by .gitignore.
    Returns a list of files, or None if the command fails (e.g., not a git repo).
    """
    cmd = ['git', 'ls-files', '--cached', '--others', '--exclude-standard']
    
    try:
        # Run the command from the target directory
        result = subprocess.run(
            cmd,
            cwd=directory,
            capture_output=True,
            text=True,
            check=True,
            encoding='utf-8'
        )
        return result.stdout.splitlines()
    except (FileNotFoundError, subprocess.CalledProcessError):
        # FileNotFoundError if 'git' isn't installed
        # CalledProcessError if it's not a git repo
        return None

def get_manual_files(directory):
    """
    Manually walks the directory, respecting .gitignore rules via 'pathspec'.
    This is a fallback for when 'git' is not available.
    """
    if pathspec is None:
        print("Error: 'pathspec' library not found, cannot scan non-git directory.", file=sys.stderr)
        sys.exit(1)

    spec = None
    gitignore_path = os.path.join(directory, '.gitignore')
    
    # Load .gitignore rules from the root directory
    if os.path.exists(gitignore_path):
        with open(gitignore_path, 'r', encoding='utf-8') as f:
            # Use 'gitwildmatch' for standard .gitignore syntax
            spec = pathspec.PathSpec.from_lines('gitwildmatch', f)
    
    file_list = []
    # We must manually exclude .git directories, as pathspec doesn't always
    # get to prune them before os.walk enters them.
    DEFAULT_EXCLUDE_DIRS = ('.git', '.svn', 'CVS', 'node_modules', '__pycache__')

    for root, dirs, files in os.walk(directory, topdown=True):
        # Prune common excluded directories for performance
        dirs[:] = [d for d in dirs if d not in DEFAULT_EXCLUDE_DIRS]
        
        for file in files:
            full_path = os.path.join(root, file)
            # Get path relative to the starting directory
            relative_path = os.path.relpath(full_path, directory)
            
            # Normalize to use forward slashes, which pathspec expects
            relative_path_posix = relative_path.replace(os.sep, '/')

            # Check if the file matches the .gitignore spec
            if spec and spec.match_file(relative_path_posix):
                continue
                
            file_list.append(relative_path)
            
    return file_list

def main():
    parser = argparse.ArgumentParser(
        description="Prints all project files (respecting .gitignore) to stdout, formatted with paths and backticks.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Example usage:
  # Print all files (uses 'git' if available, otherwise manual walk)
  ./context.py

  # Print only python files in a 'src' directory
  ./context.py src --select "*.py"

  # Print all files except logs and compiled files
  ./context.py --blacklist "*.log" --blacklist "*.pyc"
"""
    )
    
    parser.add_argument(
        'directory',
        nargs='?',
        default='.',
        help="The root directory to scan. Defaults to the current directory. (default: '.')"
    )
    parser.add_argument(
        '-b', '--blacklist',
        action='append',
        default=[],
        help="Filename patterns to exclude (e.g., '*.log'). Use multiple times for multiple patterns."
    )
    parser.add_argument(
        '-s', '--select',
        action='append',
        default=[],
        help="Filename patterns to *only* include (e.g., '*.py'). If used, only matching files are included."
    )

    if argcomplete:
        argcomplete.autocomplete(parser)

    args = parser.parse_args()
    target_dir = os.path.abspath(args.directory)
    
    if not os.path.isdir(target_dir):
        print(f"Error: Directory not found: {target_dir}", file=sys.stderr)
        sys.exit(1)

    # --- This is the new/modified logic ---
    all_files = get_git_files(target_dir)
    
    if all_files is None:
        print(f"Note: Not a git repository (or 'git' not found). Falling back to manual walk.", file=sys.stderr)
        print(f"Note: Manual walk may be slower and only respects the root '.gitignore'.\n", file=sys.stderr)
        all_files = get_manual_files(target_dir)
    # --- End of new logic ---

    output_files = []
    for filepath in all_files:
        # 1. Check select patterns (if any are provided)
        if args.select:
            if not any(fnmatch.fnmatch(filepath, pattern) for pattern in args.select):
                continue
        
        # 2. Check blacklist patterns
        if any(fnmatch.fnmatch(filepath, pattern) for pattern in args.blacklist):
            continue
            
        output_files.append(filepath)

    # 3. Print the final filtered list
    for i, filepath in enumerate(output_files):
        # The full path is needed for reading the file
        full_path = os.path.join(target_dir, filepath)
        
        # Normalize to forward slashes for the header
        header_path = filepath.replace(os.sep, '/')
        print(f"{header_path}")
        
        print("```")
        try:
            with open(full_path, 'r', encoding='utf-8', errors='ignore') as f:
                print(f.read())
        except IOError as e:
            print(f"[Error reading file: {e}]")
        
        print("```")
        
        if i < len(output_files) - 1:
            print("\n")

if __name__ == "__main__":
    main()
