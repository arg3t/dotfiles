# ═══════════════════════════════════════════════════════════════════════════
#  Nushell configuration — migrated from zsh
#  Prompt: starship (starship.toml)
#  Nushell-native replacements: syntax highlighting, history search,
#    directory jumping (zoxide), archive extraction
# ═══════════════════════════════════════════════════════════════════════════

# ─── Initialization ─────────────────────────────────────────────────────

# Theme — catppuccin mocha (static file, lives alongside config.nu)
const _theme = ($nu.default-config-dir | path join "catppuccin_mocha.nu")
source $_theme

$env.config.show_banner = false
try { fortune -a | cowsay | lolcrab -g cool }       # welcome banner; silent if tools missing

# Init scripts pre-generated by env.nu into $nu.cache-dir.
# source requires compile-time constant paths; const resolves $nu.* at parse time.
const _direnv_hook   = if (($nu.cache-dir | path join "direnv-hook.nu")   | path exists) { ($nu.cache-dir | path join "direnv-hook.nu")   } else { null }
const _starship_init = if (($nu.cache-dir | path join "starship-init.nu") | path exists) { ($nu.cache-dir | path join "starship-init.nu") } else { null }
const _zoxide_init   = if (($nu.cache-dir | path join "zoxide-init.nu")   | path exists) { ($nu.cache-dir | path join "zoxide-init.nu")   } else { null }
source $_direnv_hook                       # .envrc support
source $_starship_init                     # prompt
source $_zoxide_init                       # z / zi directory jumping

# ─── History ────────────────────────────────────────────────────────────
# Replaces: HISTSIZE/SAVEHIST + zsh-history-substring-search
# Ctrl-R search is built into nushell.
$env.config.history = {
    max_size: 100000
    sync_on_enter: true
    file_format: "sqlite"
}

# ─── Bookmarks ──────────────────────────────────────────────────────────
# Short names for frequent directories.
# Usage: cd dl, cd proj, etc.  Run `bm` to list available bookmarks.
#
# Defined as a function because nushell `def` bodies cannot close over
# top-level `let` variables.  The function is cheap (record literal).
def __bookmarks [] {
    {
        dl:   ($env.HOME | path join "Downloads")
        pic:  ($env.HOME | path join "Pictures")
        proj: ($env.HOME | path join "Projects")
        doc:  ($env.HOME | path join "Documents")
        nc:   ($env.HOME | path join "Nextcloud")
    }
}

# nushell's `cd` is a parser keyword and cannot be wrapped/overridden.
# j  — jump: `j proj` cd's to ~/Projects.  --env propagates cd to caller scope.
# bk — resolve: `cd (bk proj)` resolves a bookmark to its path.
# bm — list all bookmark names.

def --env j [...args] {
    let bm = __bookmarks
    if ($args | length) == 0 {
        cd
    } else if ($args.0 | into string) in $bm {
        cd ($bm | get ($args.0 | into string))
    } else {
        cd $args.0
    }
}

def bk [name: string] {
    let bm = __bookmarks
    if $name in $bm {
        $bm | get $name
    } else {
        print -e $"Unknown bookmark: $name"
        return 1
    }
}

def bm [] {
    __bookmarks | columns
}

# ─── Aliases — General ──────────────────────────────────────────────────
alias feh       = feh --scale-down --auto-zoom --no-fehbg
alias open      = xdg-open
alias clip      = wl-copy
alias g         = git
alias t         = tmux
alias tn        = tmux new -s
alias tat       = tmux a -t
alias lf        = lf-ueberzug
alias v         = nvim
alias vim       = nvim
alias hx        = helix
alias cx        = chmod +x
alias gshh      = gcloud cloud-shell ssh --authorize-session
alias sshlogin  = ssh -o IdentitiesOnly=yes
alias scplogin  = scp -o IdentitiesOnly=yes
alias pastebin  = curl -F sprunge=<- http://sprunge.us
alias lights_on = curl http://yeetclock/setcolor?R=136&G=192&B=208
alias bon       = sudo bash -c 'rc-service bluetooth start && rfkill unblock bluetooth'
alias clippie   = cargo clippy --fix --allow-dirty --all-targets --all-features --allow-staged --broken-code -p

# Debuggers
alias pwndbg = gdb -nh -x ($env.XDG_CONFIG_HOME | path join "gdb/pwninit")
alias gef    = gdb -nh -x ($env.XDG_CONFIG_HOME | path join "gdb/gefinit")

# Homedir cleanup — force XDG-compliant paths
alias yarn       = yarn --use-yarnrc ($env.XDG_CONFIG_HOME | path join "yarn/config")
alias tmate      = tmate -f ($env.XDG_CONFIG_HOME | path join "tmate/tmate.conf")
alias mc         = mc --config-dir=($env.XDG_CONFIG_HOME | path join "mc")
alias abook      = abook --config ($env.XDG_CONFIG_HOME | path join "abook/abookrc") --datafile ($env.XDG_DATA_HOME | path join "abook/addressbook")
alias imapfilter = imapfilter -c $env.IMAPFILTER_CONFIG

# ─── Git ────────────────────────────────────────────────────────────────
alias ga  = git add
alias gcl = git clone --recursive --depth=16
alias gck = git checkout
alias gmg = git merge
alias gss = git stash
alias gsp = git stash pop
alias gc  = git commit
alias gcm = git commit -m
alias gp  = git push
alias gpl = git pull

def gpall [] {
    git remote | lines | each { |remote| git push ($remote | str trim) }
}

def hawk [...args] {
    if (($args | length) > 0) and ($args.0 == "tuah") {
        git push -u origin HEAD
    } else {
        git $args
    }
}

# ─── Dotfiles ───────────────────────────────────────────────────────────
def dot [...args] {
    let dot_git = ($env.HOME | path join ".dotfiles.git")
    let home = $env.HOME

    # We use 'with-env' to ensure Git sees the environment it expects
    with-env { GIT_DIR: $dot_git, GIT_WORK_TREE: $home } {
        git ...$args
    }
}

def --wrapped da [...args] { dots add -u ...$args }
alias dcm = dots commit

def dpall [] {
    dot remote | lines | each { |remote| dots push ($remote | str trim) }
}

def dignore [] {
    dots update-index --assume-unchanged pkg.list install.sh README.md
}

# ─── Python venv management ─────────────────────────────────────────────
# Nushell cannot source bash activate scripts.  These functions manipulate
# PATH and VIRTUAL_ENV directly — equivalent effect, no bash required.

# Activate a venv given its root path
def activate [venv_path: string] {
    let resolved = ($venv_path | path expand)
    let bin      = ($resolved | path join "bin")
    $env.VIRTUAL_ENV = $resolved
    $env.PATH = [$bin] + ($env.PATH | where { $in != $bin })
}

# Activate the local .venv in cwd; create it (+ .envrc) if missing
def venvinit [] {
    if not (".venv/bin/activate" | path exists) {
        python -m venv .venv
        "source .venv/bin/activate" | save .envrc
        direnv allow
    }
    activate (pwd | path join ".venv")
}

# Activate a local .venv (shortcut for venvinit when .venv already exists)
def pysrcl [] { activate (pwd | path join ".venv") }

# Activate a named venv from ~/.venv/<name>/ with per-cwd caching.
# Note: original zsh version had a typo in cache filename ("pyhon_envs");
# this uses the corrected name "python_envs".  Delete the old cache file
# if it exists: ~/.cache/pyhon_envs
def pysrc [env_name?: string] {
    let cache_file = ($env.XDG_CACHE_HOME | path join "python_envs")

    mut name = $env_name
    if ($name == null) {
        if ($cache_file | path exists) {
            let cwd     = pwd
            let all_lines = (cat $cache_file | lines)
            # File format: alternating lines of cwd / env_name
            let matches = ($all_lines | enumerate | where { $in.item == $cwd })
            if (($matches | length) > 0) {
                let idx      = ($matches | first).index
                let next_idx = $idx + 1
                $name = ($all_lines | .[$next_idx])
            }
        }
    }

    if ($name == null) {
        print "No cached env, please provide an env name"
        return
    }

    let venv_root     = ($env.HOME | path join ".venv" $name)
    let bin           = ($venv_root | path join "bin")
    let activate_path = ($bin | path join "activate")
    if not ($activate_path | path exists) {
        print -e $"No venv found for $name: $venv_root"
        return 1
    }

    activate $venv_root

    # Persist cwd → env_name mapping
    let cwd = pwd
    if ($cache_file | path exists) {
        let content = (cat $cache_file | lines)
        if not ($cwd in $content) {
            $"${cwd}\n${name}\n" | save --append $cache_file
        }
    } else {
        $"${cwd}\n${name}\n" | save $cache_file
    }
}

# Bootstrap pyenv: add shims + bin to PATH (replaces eval "$(pyenv init -)")
def activate-pyenv [] {
    let root  = if ($env.PYENV_ROOT? != null) { $env.PYENV_ROOT } else { ($env.HOME | path join ".pyenv") }
    $env.PYENV_ROOT = $root
    let shims = ($root | path join "shims")
    let bin   = ($root | path join "bin")
    $env.PATH = [$shims, $bin] + ($env.PATH | where { $in != $shims and $in != $bin })
}

# ─── Tmux / Weechat ─────────────────────────────────────────────────────
def weechat [] {
    let exists = (try { tmux has-session -t weechat; true } catch { false })
    if $exists {
        tmux a -t weechat
    } else {
        tmux new-session -s weechat weechat
    }
}

# ─── Tmate pair programming ─────────────────────────────────────────────
# Original used xclip (X11); migrated to wl-copy (Wayland, matches clip alias).
let _whoami = (run-external "whoami" | str trim)
$env.TMATE_PAIR_NAME       = $"${_whoami}-pair"
$env.TMATE_SOCKET_LOCATION = ($env.XDG_RUNTIME_DIR | path join "tmate-pair.sock")
$env.TMATE_TMUX_SESSION    = ($env.XDG_RUNTIME_DIR | path join "tmate-tmux-session")

def tmate-url [] {
    let url = tmate -S $env.TMATE_SOCKET_LOCATION display -p '#{tmate_ssh}'
    ($url | str trim) | wl-copy
    print $"Copied tmate url for $env.TMATE_PAIR_NAME:"
    print $url
}

def tmate-url-ro [] {
    let url = tmate -S $env.TMATE_SOCKET_LOCATION display -p '#{tmate_ssh_ro}'
    ($url | str trim) | wl-copy
    print $"Copied tmate url for $env.TMATE_PAIR_NAME:"
    print $url
}

def tmate-attach [session?: string] {
    if ($session != null) {
        let exists = (try { tmux has-session -t $session; true } catch { false })
        if not $exists {
            print "Tmux session not found... Creating"
            tmux new-session -d -s $session
            sleep 1000ms
        }
        print $"Attaching tmate to tmux session $session"
        $session | save $env.TMATE_TMUX_SESSION
        tmate -S $env.TMATE_SOCKET_LOCATION send -t $env.TMATE_PAIR_NAME $"TMUX='' tmux attach-session -t $session; tmate-unpair" ENTER
    }
}

def tmate-pair [session?: string] {
    let api_key = (pass show "AppPass/tmate.com/api-key" | str trim)
    if ($api_key | is-empty) {
        print "You need an api key."
        return
    }

    let socket    = $env.TMATE_SOCKET_LOCATION
    let conf      = ($env.XDG_CONFIG_HOME | path join "tmate/tmate.conf")
    let pair_name = $env.TMATE_PAIR_NAME

    if not ($socket | path exists) {
        tmate -k $api_key -r "sharedProgramming" -S $socket -f $conf new-session -d -s $pair_name

        mut url = ""
        while ($url | is-empty) {
            $url = (tmate -S $socket display -p '#{tmate_ssh_ro}')
            sleep 100ms
        }
        ($url | str trim) | wl-copy
        print $"Copied tmate url for $pair_name:"
        print $url

        tmate -S $socket send -t $pair_name "q" ENTER
        sleep 1000ms
        if ($session != null) {
            tmate-attach $session
            sleep 2000ms
        }
    }
    tmate -S $socket attach-session -t $pair_name
}

def tmate-unpair [] {
    if ($env.TMATE_SOCKET_LOCATION | path exists) {
        if ($env.TMATE_TMUX_SESSION | path exists) {
            let session = (cat $env.TMATE_TMUX_SESSION | str trim)
            tmux detach -s $session
            rm --force $env.TMATE_TMUX_SESSION
        }
        tmate -S $env.TMATE_SOCKET_LOCATION kill-session -t $env.TMATE_PAIR_NAME
        print $"Killed session $env.TMATE_PAIR_NAME"
    } else {
        print "Session already killed"
    }
}

# ─── Utility functions ──────────────────────────────────────────────────

# Byte-count a string (matches original `echo -n $1 | wc -c`)
def count [s: string] {
    print -n $s | wc -c | str trim | into int
}

# Hex string → decimal (nushell parses 0x-prefixed integers natively)
def dec [h: string] {
    $"0x$h" | into int
}

# Decimal integer → uppercase hex string (pure nushell, no external)
def hex [n: int] {
    if ($n == 0) { return "0" }
    let digits = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F']
    mut result = ""
    mut num    = $n
    while ($num > 0) {
        let div16     = ($num / 16) | into int
        let remainder = $num - ($div16 * 16)
        let digit     = ($digits | .[$remainder])
        $result = $"${digit}${result}"
        $num = $div16
    }
    $result
}

# Display 256-color terminal palette
def colors [] {
    for i in (1..255) {
        let s    = ($i | into string)
        let slen = ($s | str length)
        # Manual left-pad: fill is a table command, not a string command
        let pad    = if ($slen == 1) { "  " } else if ($slen == 2) { " " } else { "" }
        let padded = $"${pad}${s}"
        print -n $"\u{001b}[38;5;${i}m${padded}\u{001b}[0m "
        let div8 = ($i / 8) | into int
        let mod8 = $i - ($div8 * 8)
        if ($mod8 == 0) { print "" }
    }
}

# Extract any common archive format (replaces le0me55i/zsh-extract)
def extract [file: string] {
    let f = ($file | path expand)
    if not ($f | path exists) {
        print -e $"File not found: $f"
        return 1
    }
    let lower = ($file | str downcase)
    if ($lower | str ends-with ".tar.gz") or ($lower | str ends-with ".tgz") {
        tar xzf $f
    } else if ($lower | str ends-with ".tar.bz2") or ($lower | str ends-with ".tbz2") {
        tar xjf $f
    } else if ($lower | str ends-with ".tar.xz") {
        tar xJf $f
    } else if ($lower | str ends-with ".tar") {
        tar xf $f
    } else if ($lower | str ends-with ".gz") {
        gunzip $f
    } else if ($lower | str ends-with ".bz2") {
        bunzip2 $f
    } else if ($lower | str ends-with ".xz") {
        unxz $f
    } else if ($lower | str ends-with ".zip") {
        unzip $f
    } else if ($lower | str ends-with ".7z") {
        7z x $f
    } else if ($lower | str ends-with ".rar") {
        unrar x $f
    } else if ($lower | str ends-with ".Z") {
        uncompress $f
    } else {
        print -e $"Unknown archive format: $file"
    }
}

# Upload a file to transfer.sh
def transfer [file: string] {
    curl --upload-file $file $"https://transfer.sh/$file"
}

# Compress a PDF via Ghostscript
def pdfcomp [input: string, output: string] {
    gs -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 -dPDFSETTINGS=/screen -dNOPAUSE -dQUIET -dBATCH -sOutputFile=$output $input
}

# Generate a .ccls config stub for C++ projects
def genccls [] {
    ["-I", "../include", "-I", "../vendor/include", "-std=c++14", "-stdlib=libc++", "-fPIC"]
    | str join "\n"
    | save .ccls
}

# ─── URL encoding ───────────────────────────────────────────────────────
# Encode uses nushell's built-in @uri format string — no external needed.
def urlencode [s: string] {
    $s | @uri
}

# Decode uses python (nushell has no built-in percent-decode)
def urldecode [encoded: string] {
    python3 -c $"import urllib.parse; print(urllib.parse.unquote('$encoded'), end='')"
}

# ─── fzf directory helper ───────────────────────────────────────────────
# Replaces fzf-tab cd preview.  Usage: cd (fzf-dir)
def fzf-dir [] {
    fd --type d | fzf --preview "ls -1 --color {}" | str trim
}
